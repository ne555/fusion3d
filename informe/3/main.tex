\documentclass{pfc}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\makeatletter
 \renewcommand{\ALG@name}{Algoritmo}
\makeatother
\renewcommand{\algorithmicfunction}{}


\newcommand{\Alerta}[1]{{\Huge\bfseries\sffamily#1}}

\title{Integración y pruebas}
\begin{document}
	\maketitle
	\section{Introducción}

	En esta etapa se integraron los módulos de registración, fusión y relleno de huecos.

	Se realizaron pruebas de rendimiento utilizando los modelos de la base de datos Stanford.

	Se resolvieron todas las funcionalidades propuestas.

	\section{Integración}
	\subsection{Formato de nube utilizado en cada módulo}
		Para la registración fue conveniente, en un primer momento, mantener
		separadas las normales de las posiciones, por lo que al probar diversas
		alternativas se siguió manteniendo esta forma.
		Sin embargo, el ajuste por ICP, la fusión y el relleno de huecos
		requerían que esta información estuviera junta para cada punto.

		Para el momento en que se comenzó con la fusión, modificar la
		registración era prohibitivamente costoso, ya que no se podía destinar nada de tiempo a la tarea.
		Además, ya se contaban con los resultados de esa etapa (las transformaciones de las vistas).
		Por eso se idearon funciones de conversión entre esos formatos en lugar de modificar la registración.

		Se planea una posterior modificación de la registración de forma que el
		formato utilizado transparente para el usuario.

	
	\subsection{Pasaje de registración de a pares a toda la lista}
		El algoritmo de alineación inicial funciona mediante pares de capturas,
		retornando entonces una transformación parcial entre las vistas.
		El ajuste por ICP también trabaja de a pares, por lo que no requiere aplicar la transformación.

		Si bien la corrección por bucle requiere de las transformaciones
		totales, el algoritmo ignora las nubes de puntos, por lo que no es
		necesario aplicar la transformación.

		Por esto, no es necesario aplicar la transformación hasta que el módulo de fusión lo requiera.
		Las capturas pueden mantenerse en su marco original, 
		donde $z$ es la distancia a la cámara (considerando perspectiva),
		si esto representa una ventaja para el usuario

	\subsection{Relleno de huecos}
		El resultado del módulo de fusión es una nube de puntos con su correspondiente triangulación.
		Sin embargo, el rellenado de huecos mediante \emph{advancing front}
		descarta todos aquellos puntos que no pertenezcan
		a la mayor componente conectada en la triangulación.

		Esto se realiza para simplificar la implementación del método al no
		tener que considerar posibles islas.
		Una versión futura podría evitar esta pérdida de información.

		En el caso del método de Poisson, la triangulación es completamente ignorada.



	\section{Funcionalidades}
		Respondiendo a los requerimientos identificados previamente,
		se implementaron las siguientes funcionalidades

		\begin{itemize}
			\item{Preproceso}
				Se realizó una reducción de ruido al ajustar los puntos mediante mínimos cuadrados móviles.

			\item {Outliers}
				El ruido y los puntos extremos se consideran en varias etapas de la reconstrucción.
				Durante el preproceso, una triangulación Delaunay identifica y elimina puntos extremos.
				Durante la fusión, los puntos sin confirmación y poca confianza se consideran provenientes de ruido.
				Luego, al utilizar únicamente la componente de mayor tamaño, se eliminan pequeños grupos de puntos.

			\item {Registración}
				Se proveen dos métodos para la alineación inicial en el módulo de registración.
				Además, se cuenta con un refinamiento posterior mediante ICP.

			\item {Área solapada}
				El área solapada, o puntos de común, entre dos nubes
				se definió como aquellos puntos que estén a menos de un umbral de distancia
				al punto más cercano en la otra nube.
				Para encontrar el más cercano se utilizó un k-d tree.

				\Alerta{TODO:} cloud\_diff\_with\_threshold() y seccinonar() crea otra nube, hacer una que devuelva los índices.

			\item {Métricas}
				Cómo métricas de calidad de la registración se utilizaron la distancia entre
				las nubes considerando sólo los puntos en común, y la razón de tamaños entre la
				nube de entrada y los puntos en común.

			\item {Corrección de bucle}
				El error de alineación del bucle se define como la transformación total
				calculada por el par primera-última al completar la vuelta. Debido a que `primera`
				definió el marco de referencia, si no se tuviera error se obtendría la identidad.
				Calculando la inversa de esta transformación se obtiene la corrección que será distribuida
				a las otras registraciones.

			\item {Combinación de nubes}
				El módulo de fusión provee esta funcionalidad, utilizando una
				representación de surfel con visibilidad, confianza y vecindad.

			\item {Triangulación tridimensional}
				La triangulación se realiza mediante el método de \emph{Greedy
				Projection Triangulation} provisto por PCL.
				Se estableció un umbral en el tamaño de los triángulos considerando la resolución de la nube,
				así como también límites para sus ángulos.

			\item {Identificar huecos}
				La malla se almacena mediante una estructura de media arista. Los
				huecos se identifican como aquellas aristas que inciden en sólo una
				cara.
				Se hizo uso de PCL::getBoundBoundary transformando su resultado para
				obtener los puntos del contorno del hueco y ordenarlos según tamaño
				(cantidad de puntos).

			\item {Relleno}
				El módulo de relleno de huecos da respuesta mediante los algoritmos de advancing front y
				la llamada a PCL::Poisson.
		\end{itemize}


		En cuanto a  los tiempos de ejecución,
		la mayor parte del proceso se realiza en
		el módulo de registración, cuyos tiempos
		pueden observarse en la tabla \Alerta{poner tabla} \Alerta{ver orden}.

		Para lograr funcionamiento tanto en Linux como Windows,
		se utilizaron bibliotecas multiplataforma:
		PCL, para el procesamiento de las nubes de puntos;
		Delaunator, para la triangulación Delaunay;
		y DKM, para el algoritmo de k-means.


	\bibliographystyle{alpha}
	\bibliography{biblio}
\end{document}

